# *Tree*

|Problem|Abstract|Code|Difficulty|
| --- | --- | --- | --- |
|0100-Same-Tree|（递归）判断一棵树是否是完全相等（左右子树都相同）的树|[Java](../LeetCode/Java/0100-Same-Tree/src)|Easy|
|0102-Binary-Tree-Level-Order-Traversal|树的层序遍历，分层输出。|[Java](../LeetCode/Java/0102-Binary-Tree-Level-Order-Traversal/src)|Medium|
|0103-Binary-Tree-Zigzag-Level-Order-Traversal|树的层序遍历，“之”字形输出。|[Java](../LeetCode/Java/0103-Binary-Tree-Zigzag-Level-Order-Traversal/src)|Medium|
|0111-Minimum-Depth-of-Binary-Tree|树的最小深度。|[Java](../LeetCode/Java/0111-Minimum-Depth-of-Binary-Tree/src)|Easy|
|0101-Symmetric-Tree|判断二叉树是否是左右完全对称。|[Java](../LeetCode/Java/0101-Symmetric-Tree/src)|Easy|
|0110-Balanced-Binary-Tree|判断二叉树是否是平衡二叉树。|[Java](../LeetCode/Java/0110-Balanced-Binary-Tree/src)|Easy|
|0112-Path-Sum|给出一棵二叉树和一个目标sum，判断是否有路径从根节点到叶节点和等于目标sum。|[Java](../LeetCode/Java/0112-Path-Sum/src)|Easy|
|0404-Sum-of-Left-Leaves|计算一棵二叉树所有左叶子的和。|[Java](../LeetCode/Java/0404-Sum-of-Left-Leaves/src)|Easy|
|0257-Binary-Tree-Paths|给定一棵二叉树，返回所有从根节点到叶节点路径的字符串。|[Java](../LeetCode/Java/0257-Binary-Tree-Paths/src)|Easy|

## *So Easy*
|Problem|Code|Difficulty|
| --- | --- | --- |
|0144-Binary-Tree-Preorder-Traversal|[Java](../LeetCode/Java/0144-Binary-Tree-Preorder-Traversal/src)|Medium|
|0094-Binary-Tree-Inorder-Traversal|[Java](../LeetCode/Java/0094-Binary-Tree-Inorder-Traversal/src)|Medium|
|0145-Binary-Tree-Postorder-Traversal|[Java](../LeetCode/Java/0145-Binary-Tree-Postorder-Traversal/src)|Hard|
|0107-Binary-Tree-Level-Order-Traversal-II|[Java](../LeetCode/Java/0107-Binary-Tree-Level-Order-Traversal-II/src)|Easy|
|0199-Binary-Tree-Right-Side-View|[Java](../LeetCode/Java/0199-Binary-Tree-Right-Side-View/src)|Medium|
|0104-Maximum-Depth-of-Binary-Tree|[Java](../LeetCode/Java/0104-Maximum-Depth-of-Binary-Tree/src)|Easy|
|0226-Invert-Binary-Tree|[Java](../LeetCode/Java/0226-Invert-Binary-Tree/src)|Easy|
|0222-Count-Complete-Tree-Nodes|[Java](../LeetCode/Java/0222-Count-Complete-Tree-Nodes/src)|Medium|
|0113-Path-Sum-II|[Java](../LeetCode/Java/0113-Path-Sum-II/src)|Medium|