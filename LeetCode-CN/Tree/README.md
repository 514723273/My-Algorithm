# 树

## 心得

0. 基础：先不要考虑边界，先考虑拿到左右子树的递归结果，能否通过当前节点，完成题目要求。
1. 最终（优）解是通过根节点求出，可以考虑后序遍历。（把左右子树当作已知解，来求解根节点）

| 问题                                                                                           | 标签              | 描述                                                                       | 题解                                            | 难度（成功/失败） |
| ---------------------------------------------------------------------------------------------- | ----------------- | -------------------------------------------------------------------------- | ----------------------------------------------- | ----------------- |
| [617.合并二叉树](https://leetcode-cn.com/problems/merge-two-binary-trees/)                     | [后序][重构][top] | 合并两颗二叉树（相同位置节点值相加）                                       | [JavaScript](./617.合并二叉树.js)               | Easy(2/0)         |
| [226.翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)                         | [后序][重构][top] | 左右翻转一颗二叉树。                                                       | [JavaScript](./226.翻转二叉树.js)               | Easy(2/0)         |
| [104.二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)         | [后序][查询][top] | 给定一个二叉树，找出其最大深度。                                           | [JavaScript](./104.二叉树的最大深度.js)         | Easy(2/0)         |
| [538.把二叉搜索树转换为累加树](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/) | [中序][查询][top] | 转换成为累加树，使得每个节点的值是原来的节点值加上所有大于它的节点值之和。 | [JavaScript](./538.把二叉搜索树转换为累加树.js) | Easy(0/1)         |
